---
title: "A possible problem with QTL plots"
author: "John Kirkpatrick"
date: "6/11/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(knitr)
library(qtlr)
library(runjags)

study2 <- tibble(Exposure=c(10.5, 9.5, 11, 10, 9), 
                 Events=c(1, 1, 1, 1, 7),
                 Rate=Events/Exposure)

createQtlPlot <- function(mcmcData,
                          mcmcVar=Value,
                          groupData,
                          groupResponse=ObservedResponse,
                          groupSize=N,
                          groupType=NULL,
                          basicTheme=ggplot2::theme_light,
                          qtls=c(0.1, 0.2, 0.8, 0.9),
                          postScaleFactor=NULL,
                          mcmcAlpha=0.2,
                          xAxisRange=NULL,
                          nDensity=512)
{
  #Validate
  if (is.null(groupData)) stop("groupData cannot be null")
  if (is.null(quote(groupResponse))) stop("groupResponse cannot be null")
  if (!tibble::is_tibble(groupData)) stop("groupData must be a tibble")
  if (is.null(mcmcData)) stop("mcmcData cannot be null")
  if (!tibble::is_tibble(mcmcData)) stop("mcmcData must be a tibble.")
  if (is.null(quote(mcmcVar))) stop("mcmcVar cannot be null")
  if (!is.null(xAxisRange)) if (length(xAxisRange) != 2) stop("xAxisRange must either be NULL or a numeric vector of length 2")
  #Begin
  qResp <- dplyr::enquo(groupResponse)
  qSize <- dplyr::enquo(groupSize)
  if (!is.null(quote(groupType))) qGroup <- dplyr::enquo(groupType)
  qVar <- dplyr::enquo(mcmcVar)
  plot <- groupData %>% ggplot2::ggplot()
  #Plot the observed data
  if (is.null(qGroup)) {
    plot <- plot + ggplot2::geom_linerange(ggplot2::aes_q(x=qResp, ymin=0, ymax=qSize))
  } else {
    plot <- plot + ggplot2::geom_linerange(ggplot2::aes_q(x=qResp, ymin=0, ymax=qSize, colour=qGroup))
  }
  #Plot the posterior density.  Could use geom_density directly, but shading
  #the action limits requires manipulation...
  if (!is.null(qtls) & length(qtls) > 0)
  {
    #Shading required
    if (is.null(postScaleFactor)) postScaleFactor <- 2 * (groupData %>%  dplyr::summarise(Max=max(!! qSize)))$Max[1]
    qtlTibble <- qtlToQuantile(mcmcData, qtls)
    d <- ggplot2::ggplot_build(mcmcData %>% 
                    ggplot2::ggplot() +
                    ggplot2::geom_density(ggplot2::aes_q(qVar, y=~..scaled..*postScaleFactor), 
                                          n=nDensity)
                      )$data[[1]]
    d <- d %>% dplyr::mutate(Area=cut(x, 
                               breaks=c(-Inf, qtlTibble$Quantile, Inf),
                               labels=1:(nrow(qtlTibble)+1)))
    plot <- plot +
              ggplot2::geom_line(data=d, ggplot2::aes(x=x, y=y))
    for (a in unique(d$Area))
      plot <- plot + ggplot2::geom_area(data=d %>% dplyr::filter(Area == a),
                               ggplot2::aes(x=x, y=y, fill=Area),
                               alpha=mcmcAlpha)
  } else {
    #No shading required
    plot <- plot + ggplot2::geom_density(data=mcmcData,
                                         ggplot2::aes_q(qVar, y=~..scaled..*postScaleFactor), 
                                         n=nDensity)
  }
  plot <- plot + 
           basicTheme() +
           ggplot2::theme(axis.ticks.y=ggplot2::element_blank(),
                          axis.text.y=ggplot2::element_blank(),
                          axis.title.y=ggplot2::element_blank())
  if (!is.null(xAxisRange)) plot <- plot + ggplot2::coord_cartesian(xlim=xAxisRange)
  return(plot)
}
```

## The problem

Here's a fictitious data set I've ben using to test my QTL package...

```{r, echo=FALSE}
study2 %>%
  kable(digits=3)
```

I can fit a Poisson model to the data to get the action limits...

```{r}
runjags.options(silent.runjags = TRUE, silent.jags = TRUE)

qtls <- c(0.1, 0.9)
mBase <- fitPoissonModel(study2$Events, study2$Exposure)
fitIndex <- max(unique(mBase$Index), na.rm=TRUE)
limits <- qtlToQuantile(mBase %>% filter(Index==fitIndex), qtls)

limits %>% 
  kable(digits=3)
```

... and create a standard QTL plot.

```{r}
maxPlotRate <- 2

mBasePlotData <- mBase %>% filter(Parameter=="mu",
                                  Index==fitIndex)
qtlColours <- c("darkgrey", "white", "darkgrey")
qtlLabels <-c("Low", "", "High")
qtlScale <- scale_fill_manual(name="QTL", labels=qtlLabels, values=qtlColours)

plot <- createQtlPlot(mBasePlotData,
                      groupData=study2,
                      groupResponse=Rate,
                      groupSize=Exposure,
                      qtls=qtls,
                      nDensity=512,
                      xAxisRange=c(0, maxPlotRate)) + 
          labs(title=" ") +
          qtlScale
plot
```

And that shows the problem.  Look at the graph.  The site with the highest observed event rate is in the upper action area, the lower limit of which is just below 0.75.  But the table of action limits says that the upper action area starts at `r sprintf("%.3f", (limits %>% tail(1))$Quantile)`, which is higher than the highest event rate of 0.778.  Something has gone wrong.

## Possible causes

The limits table is created by the `qtlToQuantile()` function directly from the MCMC chains.  The shading on the plot is drawn from the density derived from the MCMC chains.  So the two approaches will give different answers, but I'd be surprised if the differences were visible to the naked eye.

Here's the source of the qtlToQuantile function:

```{r, asis=TRUE, eval=FALSE}
qtlToQuantile <- function(data, probs, type=4)
{
  rv <- data %>% 
          dplyr::summarise(Quantile=list(stats::quantile(Value, 
                                         probs=probs,
                                         type=type))
                          ) %>% 
          tidyr::unnest() %>% 
          tibble::add_column(Prob=probs, .before=1)
  return (rv)
}
```

And here's a reminder of the call:

```{r}
fitIndex <-max(unique(mBase$Index), na.rm=TRUE)
limits <- qtlToQuantile(mBase %>% filter(Index==fitIndex), qtls)
```
The `fitXXXModel()` functions return a tibble that contains parameter estimates for each observation in the imput dataset, plus an additional one for the "fitted" curve.  [Heather and I have previously discussed whether this is the better option, or whether it should just return the fitted curve.  I still don't know the answer to that one.]  In any case, that's why the tibble is filtered before passing to `qtlToQuantile()`.  The fitted curve is obtained from a histogram of the `Value` column in the tibble.

That all seems reasonable, but just to double check:

```{r}
v <- (mBase %>%  filter(Index == 6))$Value
quantile(v, probs=c(0.1, 0.9), type=4)
```

which matches the limits table above.

To check the limits as displayed on the graph takes a litle more effort.  The tibbles which define the contents of a plot can be obtained using the `layer_data()` function.  Its parameters are the plot object to be interrogated, and an index indicating for which element of the plot the data should be extracted.  Looking at the source of the `createQTLPlot()` function [see below], the density is the second element of the plot.

```{r}
densityData <- layer_data(plot, 2)
densityData %>% head()
```

So the action areas on the plot are defined by the highest value of x which is above the lower action limit and the smallest value which is above the upper action limit:

```{r}
densityData <- densityData %>% 
                 mutate(Area=cut(x, 
                        breaks=c(-Inf, limits$Quantile, Inf),
                        labels=1:(nrow(limits)+1)))

densityData %>% 
  group_by(Area) %>% 
  summarise(Min=min(x),
            Max=max(x)) %>% 
  kable(digits=3)
```

There are some small differences compared to the limits table, but not enough to explain the discrepancy in the graph: both the upper end of the of the middle range and the lower edge of the upper action range are above the observed rate.

I'm still thinking about what might be the reason for the discrepancy.  At the moment, I'm tending towards something to do with how ggplot handles edge values when constructing empirical densities and/or shading areas.

### Reformatting the plot to make what's happening slightly clearer

```{r}
qtlScale <- scale_fill_manual(name="QTL", 
                              labels=c("Low", "OK", "High"), 
                              values=c("red", "green", "red"))

print(qtls)

plot <- createQtlPlot(mBasePlotData,
                      groupData=study2,
                      groupResponse=Rate,
                      groupSize=Exposure,
                      qtls=qtls,
                      nDensity=512,
                      xAxisRange=c(0, maxPlotRate)) + 
          geom_vline(aes(xintercept=limits$Quantile[1]), colour="blue") +
          geom_vline(aes(xintercept=limits$Quantile[2]), colour="blue") +
          labs(title=" ") +
          qtlScale
plot
```

I can use `layer_data()`, as I did above, to see how `geom_area()` is doing the shading.  In the `plot` object the layers are

  1.  Observed frequency needles
  2.  Posterior density
  3.  Fill for the lower action area
  4.  Fill for the OK area
  5.  Fill for the upper action area
  6.  Blue overlay for the lower action limit from the `limits` object
  7.  Blue overlay for the upper action limit from the `limits` object

[You can check this with `print(plot[["layers"]])`.]

I need the fifth layer.

```{r}
layer_data(plot, 5) %>% 
  head() %>% 
  kable(caption="Head of the layer data for the upper action area")
```

The data underlying the layer isn't consistent with the `limits` object.  What does the input `plotData`, specifically the `Area` column, look like in this region?

```{r}
densityData %>% 
  filter(x >= 0.75 & x <= 0.85) %>% 
  kable(caption="The densityData for Rate in [0.75, 0.85]")
```

## Source of the createQtlPlot function

```{r, eval=FALSE}
createQtlPlot <- function(mcmcData,
                          mcmcVar=Value,
                          groupData,
                          groupResponse=ObservedResponse,
                          groupSize=N,
                          groupType=NULL,
                          basicTheme=ggplot2::theme_light,
                          qtls=c(0.1, 0.2, 0.8, 0.9),
                          postScaleFactor=NULL,
                          mcmcAlpha=0.2,
                          nDensity=512)
{
  #Validate
  if (is.null(groupData)) stop("groupData cannot be null")
  if (is.null(quote(groupResponse))) stop("groupResponse cannot be null")
  if (!tibble::is_tibble(groupData)) stop("groupData must be a tibble")
  if (is.null(mcmcData)) stop("mcmcData cannot be null")
  if (!tibble::is_tibble(mcmcData)) stop("mcmcData must be a tibble.")
  if (is.null(quote(mcmcVar))) stop("mcmcVar cannot be null")
  #Begin
  qResp <- dplyr::enquo(groupResponse)
  qSize <- dplyr::enquo(groupSize)
  if (!is.null(quote(groupType))) qGroup <- dplyr::enquo(groupType)
  qVar <- dplyr::enquo(mcmcVar)
  plot <- groupData %>% ggplot2::ggplot()
  #Plot the observed data
  if (is.null(qGroup)) {
    plot <- plot + ggplot2::geom_linerange(ggplot2::aes_q(x=qResp, ymin=0, ymax=qSize))
  } else {
    plot <- plot + ggplot2::geom_linerange(ggplot2::aes_q(x=qResp, ymin=0, ymax=qSize, colour=qGroup))
  }
  #Plot the posterior density.  Could use geom_density directly, but shading
  #the action limits requires manipulation...
  if (!is.null(qtls) & length(qtls) > 0)
  {
    #Shading required
    if (is.null(postScaleFactor)) postScaleFactor <- 2 * (groupData %>%  dplyr::summarise(Max=max(!! qSize)))$Max[1]
    qtlTibble <- qtlToQuantile(mcmcData, qtls)
    d <- ggplot2::ggplot_build(mcmcData %>% 
                    ggplot2::ggplot() +
                    ggplot2::geom_density(ggplot2::aes_q(qVar, y=~..scaled..*postScaleFactor), 
                                          n=nDensity)
                      )$data[[1]]
    d <- d %>% dplyr::mutate(Area=cut(x, 
                               breaks=c(-Inf, qtlTibble$Quantile, Inf),
                               labels=1:(nrow(qtlTibble)+1)))
    plot <- plot +
              ggplot2::geom_line(data=d, ggplot2::aes(x=x, y=y))
    for (a in unique(d$Area))
      plot <- plot + ggplot2::geom_area(data=d %>% dplyr::filter(Area == a),
                               ggplot2::aes(x=x, y=y, fill=Area),
                               alpha=mcmcAlpha)
  } else {
    #No shading required
    plot <- plot + ggplot2::geom_density(data=mcmcData,
                                         ggplot2::aes_q(qVar, y=~..scaled..*postScaleFactor), 
                                         n=nDensity)
  }
  plot <- plot + 
           basicTheme() +
           ggplot2::theme(axis.ticks.y=ggplot2::element_blank(),
                          axis.text.y=ggplot2::element_blank(),
                          axis.title.y=ggplot2::element_blank())
  return(plot)
}
```